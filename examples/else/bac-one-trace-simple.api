symbols mac/2,getchallenge/0,errormac/0,Error6300/0,Error6A80/0,pair/2,fst/1,snd/1,sdec/2,senc/2;

channels c;
private ke,km,kr,nr,ntt,kt,ke2,km2,kr2,nr2,ntt2,kt2;

var X,Y,x,y,z,m,nnk,nt,x2,y2,z2,m2,nnk2,nt2;
rewrite fst(pair(X, Y)) -> X;
rewrite snd(pair(X, Y)) -> Y;
rewrite sdec(senc(X, Y), Y) -> X;




// Description of the passport role 

 passport2 =
out(c,ntt).
  in(c,nt).
  let m = senc( pair(pair(nr,nt),kr),ke) in
  out(c,pair(m,mac(m,km))).
    in(c,y).
    [snd(y)=mac(fst(y),km)].
	 let nnk = sdec(fst(y),ke) in
        [ snd(fst(nnk)) = ntt ].
          let m = senc(pair(pair(ntt,fst(fst(nnk))),kt),ke) in 
          out(c,pair(m,mac(m,km))).
    out(c,ntt2).
  in(c,nt2).
  let m2 = senc( pair(pair(nr2,nt2),kr2),ke) in
  out(c,pair(m2,mac(m2,km))).
    in(c,y2).
    if snd(y2)=mac(fst(y2),km) then 
	  let nnk2 = sdec(fst(y2),ke) in
        if snd(fst(nnk2)) = ntt2 then
      let m2 = senc(pair(pair(ntt2,fst(fst(nnk2))),kt2),ke) in 
      out(c,pair(m2,mac(m2,km)))
      else 
      out(c,Error6300)
    else
       out(c,errormac);



// Description of the passport role 

 passport3 =
out(c,ntt).
  in(c,nt).
  let m = senc( pair(pair(nr,nt),kr),ke) in
  out(c,pair(m,mac(m,km))).
    in(c,y).
    [snd(y)=mac(fst(y),km)].
	 let nnk = sdec(fst(y),ke) in
        [ snd(fst(nnk)) = ntt ].
          let m = senc(pair(pair(ntt,fst(fst(nnk))),kt),ke) in 
          out(c,pair(m,mac(m,km))).
    out(c,ntt2).
  in(c,nt2).
  let m2 = senc( pair(pair(nr2,nt2),kr2),ke2) in
  out(c,pair(m2,mac(m2,km2))).
    in(c,y2).
    (([snd(y2)=mac(fst(y2),km2)].
	  let nnk2 = sdec(fst(y2),ke2) in
        (([ snd(fst(nnk2)) = ntt2 ].
      let m2 = senc(pair(pair(ntt2,fst(fst(nnk2))),kt2),ke2) in 
      out(c,pair(m2,mac(m2,km2))))
      ++ [snd(fst(nnk2)) != ntt2].
      out(c,Error6300)))
    ++[ snd(y2)!=mac(fst(y2),km2) ].
    out(c,errormac));

// Unlinkability

 system1  =
passport2 ;

 system2  =passport3 ;



equivalentct? system1 and system2 ; 
