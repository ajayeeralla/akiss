symbols mac/2,getchallenge/0,errormac/0,Error6300/0,Error6A80/0,pair/2,fst/1,snd/1,sdec/2,senc/2;

channels c;
private ke,km,kr,nr,ntt,kt,ke2,km2,kr2,nr2,ntt2,kt2;

var X,Y,x,y,z,m,nnk,nt,x2,y2,z2,m2,nnk2,nt2;
rewrite fst(pair(X, Y)) -> X;
rewrite snd(pair(X, Y)) -> Y;
rewrite sdec(senc(X, Y), Y) -> X;



// Description of the reader role

 reader  =
//  out(c,getchallenge).
  in(c,nt).
  // new nr; new kr;
  let m = senc( pair(pair(nr,nt),kr),ke) in
  out(c,pair(m,mac(m,km))).
//  in(c,z).
  0;

// Description of the passport role 

 passport =
  in(c,x).(
  [ x = getchallenge ].
//  then
//    new nt;
    out(c,ntt).
    in(c,y).
//    let (me,mm) = y in
  
    ([snd(y)=mac(fst(y),ke)].
//    ()if mm = mac(me,km)
//    then
//      let (nr,nt2,kr) = sdec(me,ke) in
	  let nnk = sdec(fst(y),ke) in
        [ fst(snd(nnk)) = ntt ].
//      then 
//	new kt; 
//	let m = senc((ntt,fst(fst(nnk)),kt),ke) in
      let m = senc(pair(pair(ntt,fst(fst(nnk))),kt),ke) in 
      out(c,pair(m,mac(m,km))).0
      ++ [snd(y)!=mac(fst(y),ke)].
      out(c,Error6300))
    ++[ x != getchallenge ].
    out(c,errormac).0);

// Description of the reader role

 reader2  =
//  out(c,getchallenge).
  in(c,nt2).
  // new nr; new kr;
  let m2 = senc( pair(pair(nr2,nt2),kr2),ke) in
  out(c,pair(m2,mac(m2,km))).
  // in(c,z2).
  0;

// Description of the passport role 

 passport2 =
  in(c,x2).(
  [ x2 = getchallenge ].
//  then
//    new nt;
    out(c,ntt2).
    in(c,y2).
//    let (me,mm) = y in
  
    ([snd(y2)=mac(fst(y2),ke)].
//    ()if mm = mac(me,km)
//    then
//      let (nr,nt2,kr) = sdec(me,ke) in
	  let nnk2 = sdec(fst(y2),ke) in
        [ fst(snd(nnk2)) = ntt2 ].
//      then 
//	new kt; 
//	let m = senc((ntt,fst(fst(nnk)),kt),ke) in
      let m2 = senc(pair(pair(ntt2,fst(fst(nnk2))),kt2),ke) in 
      out(c,pair(m2,mac(m2,km))).0
      ++ [snd(y2)!=mac(fst(y2),ke)].
      out(c,Error6300))
    ++[ x2 != getchallenge ].
    out(c,errormac).0);

// Description of the reader role

 reader3  =
//  out(c,getchallenge).
  in(c,nt2).
  // new nr; new kr;
  let m2 = senc( pair(pair(nr2,nt2),kr2),ke2) in
  out(c,pair(m2,mac(m2,km2))).
//  in(c,z2).
  0;

// Description of the passport role 

 passport3 =
  in(c,x2).(
  [ x2 = getchallenge ].
//  then
//    new nt;
    out(c,ntt2).
    in(c,y2).
//    let (me,mm) = y in
  
    ([snd(y2)=mac(fst(y2),ke2)].
//    ()if mm = mac(me,km)
//    then
//      let (nr,nt2,kr) = sdec(me,ke2) in
	  let nnk2 = sdec(fst(y2),ke2) in
        [ fst(snd(nnk2)) = ntt2 ].
//      then 
//	new kt; 
//	let m = senc((ntt,fst(fst(nnk)),kt),ke2) in
      let m2 = senc(pair(pair(ntt2,fst(fst(nnk2))),kt2),ke2) in 
      out(c,pair(m2,mac(m2,km2))).0
      ++ [snd(y2)!=mac(fst(y2),ke2)].
      out(c,Error6300))
    ++[ x2 != getchallenge ].
    out(c,errormac).0);

// Unlinkability

 system1  =
  //(new ke; new km; 
((passport  || reader)  >> (passport2  || reader2));
  //|
  //(new ke; new km; (passport  ke km errormac | reader ke km )).

 system2  =((passport  || reader)  >> (passport3  || reader3));
 // new ke; new km; 
//passport  || reader ;
//| passport ke km errormac | reader ke km).



equivalentct? system1 and system2 ; 
